#version 450

layout(binding = 0) uniform OldUniformBufferObject {
    vec2 center;
    uvec2 max_resolution;
    uvec2 screen_offset;
    float height_scale;
    int res_scale_exp;
} old_ubo;
layout(std430, binding = 1) buffer storage {
    float potential_vals[];
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout( push_constant ) uniform UniformBufferObject {
    vec2 center;
    uvec2 max_resolution;
    uvec2 screen_offset;
    float height_scale;
    int res_scale_exp;
} ubo;

void main() {
    const int max_count = 5000;
	const float escape_radius = 1e8;
	const float interior_test_e_sqr = 1e-6;

    uvec2 screen_loc = gl_GlobalInvocationID.xy + ubo.screen_offset;
    if (screen_loc.x >= ubo.max_resolution.x || screen_loc.y >= ubo.max_resolution.y) return;

    vec2 c = screen_loc * ubo.height_scale;// / vec2(float(ubo.max_resolution.y));
	c += ubo.center;
    vec2 pos = c;

    //potential_vals[screen_loc.x + screen_loc.y * ubo.max_resolution.x] = abs(pos.x) + abs(pos.y);
    
    int count = 1;
    float x_sqr = pos.x * pos.x;
    float y_sqr = pos.y * pos.y;
	float rad_sqr = x_sqr + y_sqr;
	float interior_test_sqr = rad_sqr;
    while (rad_sqr < escape_radius * escape_radius && count < max_count && interior_test_sqr > interior_test_e_sqr) {
        pos.y = 2.0 * pos.x * pos.y + c.y;
        pos.x = x_sqr - y_sqr + c.x;
        x_sqr = pos.x * pos.x;
        y_sqr = pos.y * pos.y;
		rad_sqr = x_sqr + y_sqr;
		interior_test_sqr *= 4.0 * rad_sqr;
        count++;
    }

    if (count == max_count || interior_test_sqr <= interior_test_e_sqr) {
        potential_vals[screen_loc.x + screen_loc.y * ubo.max_resolution.x] = -1;
    } else {
		potential_vals[screen_loc.x + screen_loc.y * ubo.max_resolution.x] = log2(max(1, count - log2(log2(x_sqr + y_sqr) / 2.0f) + 1.0));
	}
}
