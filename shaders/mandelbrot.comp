// BROT - A fast mandelbrot set explorer
// Copyright (C) 2025  Charles Reischer
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
// 
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#version 450

layout(std430, binding = 1) writeonly buffer storage_to_frag {
    float potential_vals[];
};

layout(std430, binding = 2) readonly buffer storage_from_cpu {
    vec2 perturbation_ref[];
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout( push_constant ) uniform UniformBufferObject {
    vec2 center;
    uvec2 cur_resolution;
    uvec2 screen_offset;
    float height_scale;
    int res_scale_exp;
    uint max_width;
} ubo;

float rad_sqr(vec2 a) {
    return a.x*a.x + a.y*a.y;
}

void main() {
    const int max_count = 20000;
	const float escape_radius = 1e6;
	const float interior_test_e_sqr = 1e-6;
    const uint pixel_scale = 1u << ubo.res_scale_exp;

    uvec2 screen_loc = pixel_scale * gl_GlobalInvocationID.xy + ubo.screen_offset;
    ivec2 center_screen_loc = ivec2(screen_loc + uvec2(pixel_scale/2, pixel_scale/2));

    center_screen_loc = ivec2(center_screen_loc - ubo.cur_resolution / 2);
    vec2 delta_c = center_screen_loc * ubo.height_scale;// / vec2(float(ubo.cur_resolution.y));
    vec2 delta_pos = delta_c;

    //potential_vals[screen_loc.x + screen_loc.y * ubo.max_width] = abs(pos.x) + abs(pos.y);
    
    int count = 1;
    int ref_index = 1;
    float dx_sqr = delta_pos.x * delta_pos.x;
    float dy_sqr = delta_pos.y * delta_pos.y;
    float dxdy = delta_pos.x * delta_pos.y;
    vec2 Z = perturbation_ref[1];
    float tot_rad = rad_sqr(Z+delta_pos);
    while (count < max_count && tot_rad < escape_radius) {
        delta_pos = 2 * vec2(
            delta_pos.x * Z.x - delta_pos.y * Z.y,
            delta_pos.x * Z.y + delta_pos.y * Z.x
        );
        delta_pos += vec2(dx_sqr - dy_sqr, 2 * dxdy) + delta_c;

        dx_sqr = delta_pos.x * delta_pos.x;
        dy_sqr = delta_pos.y * delta_pos.y;
        dxdy = delta_pos.x * delta_pos.y;
        count++;
        ref_index++;
        Z = perturbation_ref[ref_index];
        tot_rad = rad_sqr(Z+delta_pos);

        float Z_rad = rad_sqr(Z);
        float dz_rad = dx_sqr + dy_sqr;

        if (tot_rad < dz_rad) {
            ref_index = 0;
            delta_pos += Z;
            dx_sqr = delta_pos.x * delta_pos.x;
            dy_sqr = delta_pos.y * delta_pos.y;
            dxdy = delta_pos.x * delta_pos.y;
            Z = vec2(0);
            tot_rad = dx_sqr + dy_sqr;
        }
    }

    vec2 pos = Z + delta_pos;
    vec2 c = delta_c + perturbation_ref[0];

    float x_sqr = pos.x * pos.x;
    float y_sqr = pos.y * pos.y;
	float rad_sqr = x_sqr + y_sqr;
	float interior_test_sqr = rad_sqr;
    //while (rad_sqr < escape_radius * escape_radius && count < max_count && interior_test_sqr > interior_test_e_sqr) {
    //    pos.y = 2.0 * pos.x * pos.y + c.y;
    //    pos.x = x_sqr - y_sqr + c.x;
    //    x_sqr = pos.x * pos.x;
    //    y_sqr = pos.y * pos.y;
	//	rad_sqr = x_sqr + y_sqr;
	//	interior_test_sqr *= 4.0 * rad_sqr;
    //    count++;
    //}

    float potential_val;
    if (count == max_count || interior_test_sqr <= interior_test_e_sqr) {
        potential_val = -1;
    } else {
		potential_val = log2(max(1, count - log2(log2(rad_sqr) / 2.0f) + 1.0));
	}

    for (int delta_y = 0; delta_y < pixel_scale; delta_y++) {
        for (int delta_x = 0; delta_x < pixel_scale; delta_x++) {
            if (screen_loc.x + delta_x >= ubo.cur_resolution.x || screen_loc.y + delta_y >= ubo.cur_resolution.y) continue;
            potential_vals[screen_loc.x + delta_x + (screen_loc.y + delta_y) * ubo.max_width] = potential_val;
        }
    }
}
