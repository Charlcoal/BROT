#version 450

layout(std430, binding = 1) buffer storage {
    float potential_vals[];
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout( push_constant ) uniform UniformBufferObject {
    vec2 center;
    uvec2 max_resolution;
    uvec2 screen_offset;
    float height_scale;
    int res_scale_exp;
} ubo;

void main() {
    const int max_count = 15000;
	const float escape_radius = 1e8;
	const float interior_test_e_sqr = 1e-6;
    const uint pixel_scale = 1u << ubo.res_scale_exp;

    uvec2 screen_loc = pixel_scale * gl_GlobalInvocationID.xy + ubo.screen_offset;

    vec2 c = screen_loc * ubo.height_scale;// / vec2(float(ubo.max_resolution.y));
	c += ubo.center;
    vec2 pos = c;

    //potential_vals[screen_loc.x + screen_loc.y * ubo.max_resolution.x] = abs(pos.x) + abs(pos.y);
    
    int count = 1;
    float x_sqr = pos.x * pos.x;
    float y_sqr = pos.y * pos.y;
	float rad_sqr = x_sqr + y_sqr;
	float interior_test_sqr = rad_sqr;
    while (rad_sqr < escape_radius * escape_radius && count < max_count && interior_test_sqr > interior_test_e_sqr) {
        pos.y = 2.0 * pos.x * pos.y + c.y;
        pos.x = x_sqr - y_sqr + c.x;
        x_sqr = pos.x * pos.x;
        y_sqr = pos.y * pos.y;
		rad_sqr = x_sqr + y_sqr;
		interior_test_sqr *= 4.0 * rad_sqr;
        count++;
    }

    float potential_val;
    if (count == max_count || interior_test_sqr <= interior_test_e_sqr) {
        potential_val = -1;
    } else {
		potential_val = log2(max(1, count - log2(log2(x_sqr + y_sqr) / 2.0f) + 1.0));
	}

    for (int delta_y = 0; delta_y < pixel_scale; delta_y++) {
        for (int delta_x = 0; delta_x < pixel_scale; delta_x++) {
            if (screen_loc.x + delta_x >= ubo.max_resolution.x || screen_loc.y + delta_y >= ubo.max_resolution.y) continue;
            potential_vals[screen_loc.x + delta_x + (screen_loc.y + delta_y) * ubo.max_resolution.x] = potential_val;
        }
    }
}
